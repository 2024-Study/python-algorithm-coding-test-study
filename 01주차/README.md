#  📖 학습 요약

## 🔥 학습 내용
| **문제**      | **링크**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 필수          | [숫자의 합](https://www.acmicpc.net/problem/11720) / [평균](https://www.acmicpc.net/problem/1546) / [구간 합 구하기1](https://www.acmicpc.net/problem/11659) / [구간 합 구하기2](https://www.acmicpc.net/problem/11660) / [나머지 합 구하기](https://www.acmicpc.net/problem/10986) / [연속된 자연수 합](https://www.acmicpc.net/problem/2018) / [주몽](https://www.acmicpc.net/problem/1940) / ['좋은 수' 구하기](https://www.acmicpc.net/problem/1253) / [DNA 비밀번호](https://www.acmicpc.net/problem/12891) / [최솟값 찾기](https://www.acmicpc.net/problem/11003) |
| 추가          | []()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
## ✏️ 개념 정리

# 1️⃣ 코딩테스트 준비하기

시간복잡도와 디버깅에 관하여

## 01. 알고리즘의 기준이 되는 시간복잡도

### 시간복잡도 표기법 알아보기


- 시간 복잡도 : 주어진 문제를 해결하기 위한 연산 횟수
    - 파이썬에서는 **1초에 2,000만 번 ~ 1억 번**의 연산을 수행한다고 예측

| 시간복잡도 유형  | 설명  |
| --- | --- |
| 빅-오메가  | 최선일 때의 연산 횟수를 나타낸 표기법 |
| 빅-세타 | 보통일 때의 연산 횟수를 나타낸 표기법 |
| 빅-오 | 최악일 때의 연산횟수를 나타낸 표기법 |

```
# 1~100 사이의 무작위 값을 찾아 출력하는 코드

import random
findNumber = random.randrange(1,101)
    
for i in range(1,101):
  if i == findNumber:
    print(i)
    break
```


- 코딩테스트에서 사용하는 시간 복잡도 유형
    - 실제 테스트에서는 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단하므로 시간 복잡도를 판단할 때는 최악일 때를 염두에 둬야 한다.
    - 빅-오 표기법으로 표현한 시간 복잡도 그래프

      ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cdbe9529-3537-4c2b-a63a-2dafa907ab71/7e0e7ee5-c2dc-4cc8-9346-6af62bf07dd7/image.png)


### 시간 복잡도 활용하기


- **알고리즘 선택의 기준**으로 활용하기

    ```java
    # 백준 온라인 저지 2750번
    # N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오
    # 시간 제한 2초
    # 1 <= N <= 1,000,000
    ```

    - 시간제한이 2초이므로 조건을 만족하기 위해 4,000만 번 이하의 연산 횟수로 문제 해결
    - 연산횟수 계산 방법
        - 연산 횟수 = 알고리즘 시간 복잡도 n 값에 데이터의 최대 크기(N)를 대입하여 도출
    - 알고리즘 적합성 평가
        - 버블 정렬 → 부적합 알고리즘
          `n^2 = (1,000,000)^2 > 40,000,000`

        - 병합 정렬 → 적합 알고리즘
          `nlog_2n = 10,000,000*log_210,000,000 < 40,000,000`


- 시간 복잡도를 바탕으로 코드 로직 개선하기
    - 시간 복잡도 도출 기준
        - 상수는 시간 복잡도 계산에서 제외

          `연산횟수가 N인 코드의 시간 복잡도 = 연산횟수가 3N인 코드의 시간 복잡도`

        - 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.


## 02. 가장 뛰어난 오류 탐색 방법, 디버깅

### 디버깅은 왜 중요할까?

- 디버깅: 프로그램에서 발생하는 문법 오류나 논리 오류를 찾아 바로잡는 과정
- pycharm 단축키 f9 / shift + f9
- 디버깅 하는 방법
    1. 코드에서 디버깅하고자 하는 줄에 **중단점**을 설정한다. (여러 개 설정 가능)
    2. IDE의 디버깅 기능을 실행하면 코드를 1줄씩 실행하거나 다음 중단점까지 실행할 수 있으며, 이 과정에서 추적할 변숫값도 지정할 수 있다.  → Pycharm 의 Variables 기능 활용
    3. 변숫값 이외에도 원하는 수식을 입력해 논리 오류를 파악할 수 있다.


### 디버깅 활용 사례 살펴보기

- 코딩 테스트를 진행하며 실수하기 쉬운 4가지 오류
    - 변수 초기화 오류
    - 인덱스 범위 지정 오류
    - 잘못된 변수 사용 오류 (변수명 혼동)
    - 파이썬 자동 형 변환

# 3️⃣ 자료구조

## 01. 배열과 리스트

### 배열과 리스트의 핵심 이론


- 배열 : 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
    - **인덱스**를 사용하여 **값에 바로 접근 가능**
    - 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다.
      값을 **삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정 필요**
    - 배열의 크기는 선언할 때 지정할 수 있으며, **한 번 선언하면 크기를 늘리거나 줄일 수 없다.**
    - **선언한 자료형의 값만 저장 가능**
    - 구조가 간단하므로 코딩 테스트에서 많이 사용

  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cdbe9529-3537-4c2b-a63a-2dafa907ab71/f7a94b6f-75de-4288-bc41-cc68cb07d203/image.png)

- 리스트 : 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
    - 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.
      **값에 접근하는 속도가 느리다.**
    - 포인터로 연결되어 있으므로 **데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.**
    - 선언할 때 크기를 별도로 지정하지 않아도 된다.
      **리스트의 크기는 정해져 있지 않으며**, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
    - **포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡**하다.

  ![image.png](https://file.notion.so/f/f/cdbe9529-3537-4c2b-a63a-2dafa907ab71/52b6b3a2-092c-4d60-874f-4e51f8ffc604/image.png?table=block&id=f1162691-4550-4464-af6c-95ccefe8c570&spaceId=cdbe9529-3537-4c2b-a63a-2dafa907ab71&expirationTimestamp=1726185600000&signature=xIQbQxl7G526oi2oYDgzPX-VUYJx_JtXpTiTFTVr3M8&downloadName=image.png)

- 파이썬에서는 배열과 리스트를 구분 X        
  파이썬의 리스트는 리스트와 배열의 특징 모두를 가지도록 구현되었음

## 02. 구간 합

### 구간 합의 핵심 이론


- 합 배열 S의 정의

  `S[i] = A[0] + A[1] + ... + A[i-1] + A[i]`
    - 합 배열은 기존의 리스트 데이터를 전처리한 배열
    - 합 배열을 미리 구해놓으면 기존 리스트의 일정 범위의 합을 구하는 시간 복잡도가 O(N) → O(1)


- 합 배열  S를 만드는 공식

  `S[i] = S[i-1] + A[i]`


- 구간 합을 구하는 공식 : i에서 j까지의 구간 합

  `S[j] - S[i-1]`


<aside>

💡**sys.stdin.readline()**

- 반복문으로 여러 줄을 입력 받는 상황에서는 input() 이 아닌 sys.stdin.readline() 을 사용해야 시간초과가 발생하지 않는다.

- 정해진 개수의 정수를 한 줄에 입력받을 때
  ```
  import sys
  a,b,c = map(int,sys.stdin.readline().split())
  ```

- 임의의 개수의 정수를 한 줄에 입력받아 리스트에 저장할 때
  ```
  import sys
  data = list(map(int,sys.stdin.readline().split()))
  ```

- 임의의 개수의 정수를 n줄에 입력받아 2차원 리스트에 저장할 때
  ```
  import sys
  data = []
  n = int(sys.stdin.readline())
  for i in range(n):
  data.append(list(map(int,sys.stdin.readline().split())))
  ```

- 문자열 n줄을 입력받아 리스트에 저장할 때
  ```
  import sys
  n = int(sys.stdin.readline())
  data = [sys.stdin.readline().strip() for i in range(n))]
  ```

</aside>

## 03. 투 포인터

- **2개의 포인터**로 알고리즘의 시간 복잡도 최적화

### 문제 6 연속된 자연수의 합 구하기

- **시작 인덱스**와 **종료 인덱스**를 투 포인터로 지정
- 투 포인터 이동 원칙을 활용해 배열 탐색

    ```
    if sum > n: 
    elif sum < n:
    elif sum == n:
    ```


### 문제 7 주몽의 명령

- 크기를 비교 → 값을 정렬하는 아이디어
    - n 의 최대 범위가 15,000 이므로 O(nlogn) 알고리즘 사용 가능
    - 투 포인터 이동 원칙을 활용해 배열 탐색

### 문제 8 ‘좋은 수’ 구하기

- 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안 됨 유의!!
- 찾고자 하는 값 (find) 와 투 포인터 사용


## 04. 슬라이딩 윈도우

### 문제 9 DNA 비밀번호

- **2개의 포인터로 범위를 지정**한 다음, **범위를 유지한 채로 이동**하며 문제를 해결
- 첫 윈도우에서 현재 상태 리스트를 초기화한 다음, 윈도우를 한칸씩 이동할 때마다 현재 상태 리스트를 **업데이트**하는 방식 → 빠지는 문자열과 신규 문자열만을 보고 업데이트

### 문제 10 최솟값 찾기 1


- O(n) 의 시간 복잡도로 문제를 해결해야 함 → 정렬 알고리즘 사용 불가
- 슬라이딩 윈도우를 덱으로 구현하여 문제 해결 가능
    - 덱: 양 끝에서 데이터를 삽입하거나 삭제할 수 있는 자료 구조

# ✨ MEMO
